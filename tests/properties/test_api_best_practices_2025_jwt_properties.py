"""Property-based tests for JWT RS256 implementation.

**Feature: api-best-practices-review-2025**
**Validates: Requirements 2.1, 7.2, 20.1, 20.2, 20.3, 20.4**

Property tests for:
- Property 1: JWT RS256 Algorithm Enforcement
- Property 2: JWT Round-Trip Consistency
- Property 3: JWT Key Rotation Backward Compatibility
- Property 4: JWT Kid Validation
"""

from datetime import timedelta

import pytest
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from hypothesis import HealthCheck, given, settings, strategies as st
from jose import jwt

from infrastructure.auth.jwt import (
    JWKSService,
    RS256Provider,
    generate_kid_from_public_key,
)

# === Test Fixtures ===


def generate_rsa_key_pair() -> tuple[str, str]:
    """Generate a fresh RSA key pair for testing."""
    private_key = rsa.generate_private_key(
        public_exponent=65537,
        key_size=2048,
    )

    private_pem = private_key.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.PKCS8,
        encryption_algorithm=serialization.NoEncryption(),
    ).decode()

    public_key = private_key.public_key()
    public_pem = public_key.public_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PublicFormat.SubjectPublicKeyInfo,
    ).decode()

    return private_pem, public_pem


@pytest.fixture
def rsa_keys() -> tuple[str, str]:
    """Fixture providing an RSA key pair."""
    return generate_rsa_key_pair()


@pytest.fixture
def rs256_provider(rsa_keys: tuple[str, str]) -> RS256Provider:
    """Fixture providing an RS256 provider."""
    private_pem, public_pem = rsa_keys
    return RS256Provider(
        private_key=private_pem,
        public_key=public_pem,
        issuer="test-issuer",
        audience="test-audience",
    )


# === Strategies ===


user_id_strategy = st.text(
    min_size=1,
    max_size=36,
    alphabet=st.characters(whitelist_categories=("L", "N"), whitelist_characters="-_"),
).filter(lambda x: x.strip() != "")

roles_strategy = st.lists(
    st.sampled_from(["admin", "editor", "viewer", "user", "moderator"]),
    min_size=0,
    max_size=5,
    unique=True,
)


# === Property Tests ===


class TestJWTRS256AlgorithmEnforcement:
    """Property 1: JWT RS256 Algorithm Enforcement.

    For any JWT token generated by the system, the token header SHALL contain
    algorithm "RS256" and a valid "kid" (key ID) field.

    **Feature: api-best-practices-review-2025**
    **Validates: Requirements 2.1, 20.1**
    """

    @settings(
        max_examples=50,
        deadline=None,
        suppress_health_check=[HealthCheck.function_scoped_fixture],
    )
    @given(user_id=user_id_strategy, roles=roles_strategy)
    def test_token_uses_rs256_algorithm(
        self, rs256_provider: RS256Provider, user_id: str, roles: list[str]
    ) -> None:
        """Token header SHALL contain algorithm RS256.

        **Feature: api-best-practices-review-2025, Property 1: JWT RS256 Algorithm Enforcement**
        **Validates: Requirements 2.1, 20.1**
        """
        # Sign a token
        token = rs256_provider.sign({"sub": user_id, "roles": roles})

        # Get unverified header
        header = jwt.get_unverified_header(token)

        # Verify algorithm is RS256
        assert header["alg"] == "RS256", f"Expected RS256, got {header['alg']}"

    @settings(
        max_examples=50,
        deadline=None,
        suppress_health_check=[HealthCheck.function_scoped_fixture],
    )
    @given(user_id=user_id_strategy)
    def test_token_contains_kid_header(
        self, rs256_provider: RS256Provider, user_id: str
    ) -> None:
        """Token header SHALL contain a valid kid field.

        **Feature: api-best-practices-review-2025, Property 1: JWT RS256 Algorithm Enforcement**
        **Validates: Requirements 20.1**
        """
        token = rs256_provider.sign({"sub": user_id})
        header = jwt.get_unverified_header(token)

        # Verify kid is present
        assert "kid" in header, "Token header must contain kid"
        assert len(header["kid"]) > 0, "kid must be non-empty"

        # Verify kid matches provider's kid
        assert header["kid"] == rs256_provider.kid, "kid must match provider's kid"


class TestJWTRoundTripConsistency:
    """Property 2: JWT Round-Trip Consistency.

    For any valid token payload, encoding with the private key and decoding
    with the public key SHALL return an equivalent payload.

    **Feature: api-best-practices-review-2025**
    **Validates: Requirements 7.2**
    """

    @settings(
        max_examples=50,
        deadline=None,
        suppress_health_check=[HealthCheck.function_scoped_fixture],
    )
    @given(user_id=user_id_strategy, roles=roles_strategy)
    def test_sign_verify_round_trip(
        self, rs256_provider: RS256Provider, user_id: str, roles: list[str]
    ) -> None:
        """Encoding and decoding SHALL return equivalent payload.

        **Feature: api-best-practices-review-2025, Property 2: JWT Round-Trip Consistency**
        **Validates: Requirements 7.2**
        """
        payload = {"sub": user_id, "roles": roles}

        # Sign token
        token = rs256_provider.sign(payload)

        # Verify token
        claims = rs256_provider.verify(token)

        # Check original claims are preserved
        assert claims["sub"] == user_id
        assert claims["roles"] == roles

        # Verify standard claims are present
        assert "iat" in claims
        assert "exp" in claims

    @settings(
        max_examples=20,
        deadline=None,
        suppress_health_check=[HealthCheck.function_scoped_fixture],
    )
    @given(user_id=user_id_strategy)
    def test_custom_claims_preserved(
        self, rs256_provider: RS256Provider, user_id: str
    ) -> None:
        """Custom claims SHALL be preserved through round-trip.

        **Feature: api-best-practices-review-2025, Property 2**
        """
        custom_claims = {
            "sub": user_id,
            "custom_field": "test_value",
            "numeric_field": 42,
        }

        token = rs256_provider.sign(custom_claims)
        claims = rs256_provider.verify(token)

        assert claims["custom_field"] == "test_value"
        assert claims["numeric_field"] == 42


class TestJWTKeyRotation:
    """Property 3: JWT Key Rotation Backward Compatibility.

    For any token signed with a previous key (within grace period), validation
    with the current JWKS SHALL succeed if the old key is still in the key set.

    **Feature: api-best-practices-review-2025**
    **Validates: Requirements 20.3**
    """

    @settings(max_examples=20, deadline=None)
    @given(user_id=user_id_strategy)
    def test_old_key_valid_during_rotation(self, user_id: str) -> None:
        """Tokens signed with old key SHALL be valid during grace period.

        **Feature: api-best-practices-review-2025, Property 3: JWT Key Rotation**
        **Validates: Requirements 20.3**
        """
        # Generate two key pairs
        old_private, old_public = generate_rsa_key_pair()
        new_private, new_public = generate_rsa_key_pair()

        # Create JWKS service with grace period
        jwks = JWKSService(grace_period=timedelta(hours=24))

        # Add old key as current
        old_kid = jwks.add_key(old_public, "RS256")

        # Sign token with old key
        old_provider = RS256Provider(
            private_key=old_private,
            public_key=old_public,
            kid=old_kid,
        )
        token = old_provider.sign({"sub": user_id})

        # Rotate to new key
        new_kid = jwks.rotate_current_key(new_public, "RS256")

        # Old key should still be valid in JWKS
        assert jwks.validate_kid(old_kid), "Old kid should be valid during grace period"

        # Both keys should be in JWKS
        jwks_response = jwks.get_jwks()
        kids_in_jwks = [key.kid for key in jwks_response.keys]
        assert old_kid in kids_in_jwks, "Old key should be in JWKS"
        assert new_kid in kids_in_jwks, "New key should be in JWKS"


class TestJWTKidValidation:
    """Property 4: JWT Kid Validation.

    For any token with a kid header not present in the JWKS, validation
    SHALL fail with an appropriate error.

    **Feature: api-best-practices-review-2025**
    **Validates: Requirements 20.4**
    """

    @settings(max_examples=20, deadline=None)
    @given(user_id=user_id_strategy)
    def test_unknown_kid_rejected(self, user_id: str) -> None:
        """Unknown kid SHALL be rejected.

        **Feature: api-best-practices-review-2025, Property 4: JWT Kid Validation**
        **Validates: Requirements 20.4**
        """
        private_pem, public_pem = generate_rsa_key_pair()

        # Create JWKS service
        jwks = JWKSService()
        jwks.add_key(public_pem, "RS256")

        # Unknown kid should fail validation
        assert not jwks.validate_kid("unknown-kid-12345")

    @settings(max_examples=20, deadline=None)
    @given(user_id=user_id_strategy)
    def test_revoked_kid_rejected(self, user_id: str) -> None:
        """Revoked kid SHALL be rejected.

        **Feature: api-best-practices-review-2025, Property 4: JWT Kid Validation**
        **Validates: Requirements 20.4, 20.6**
        """
        private_pem, public_pem = generate_rsa_key_pair()

        # Create JWKS and add key
        jwks = JWKSService()
        kid = jwks.add_key(public_pem, "RS256")

        # Key should be valid initially
        assert jwks.validate_kid(kid)

        # Revoke the key
        jwks.revoke_key(kid)

        # Key should be invalid after revocation
        assert not jwks.validate_kid(kid)


class TestJWKSStructure:
    """Tests for JWKS structure and content.

    **Feature: api-best-practices-review-2025**
    **Validates: Requirements 20.2**
    """

    def test_jwks_contains_valid_jwk_format(self) -> None:
        """JWKS response SHALL contain valid JWK format.

        **Feature: api-best-practices-review-2025**
        **Validates: Requirements 20.2**
        """
        private_pem, public_pem = generate_rsa_key_pair()

        jwks = JWKSService()
        kid = jwks.add_key(public_pem, "RS256")

        response = jwks.get_jwks()

        # Should have one key
        assert len(response.keys) == 1

        key = response.keys[0]

        # Verify required fields
        assert key.kty == "RSA"
        assert key.alg == "RS256"
        assert key.use == "sig"
        assert key.kid == kid

        # Verify RSA parameters present
        assert key.n is not None
        assert key.e is not None

    def test_jwks_to_dict_format(self) -> None:
        """JWKS.to_dict() SHALL produce valid JSON structure.

        **Feature: api-best-practices-review-2025**
        **Validates: Requirements 20.2**
        """
        private_pem, public_pem = generate_rsa_key_pair()

        jwks = JWKSService()
        jwks.add_key(public_pem, "RS256")

        response = jwks.get_jwks()
        data = response.to_dict()

        # Should have keys array
        assert "keys" in data
        assert isinstance(data["keys"], list)

        # Each key should have required fields
        for key_dict in data["keys"]:
            assert "kty" in key_dict
            assert "kid" in key_dict
            assert "alg" in key_dict
            assert "use" in key_dict


class TestKidGeneration:
    """Tests for kid generation consistency.

    **Feature: api-best-practices-review-2025**
    **Validates: Requirements 20.1**
    """

    def test_kid_deterministic(self) -> None:
        """Same public key SHALL generate same kid.

        **Feature: api-best-practices-review-2025**
        **Validates: Requirements 20.1**
        """
        _, public_pem = generate_rsa_key_pair()

        kid1 = generate_kid_from_public_key(public_pem)
        kid2 = generate_kid_from_public_key(public_pem)

        assert kid1 == kid2, "kid generation must be deterministic"

    def test_different_keys_different_kids(self) -> None:
        """Different public keys SHALL generate different kids.

        **Feature: api-best-practices-review-2025**
        **Validates: Requirements 20.1**
        """
        _, public_pem1 = generate_rsa_key_pair()
        _, public_pem2 = generate_rsa_key_pair()

        kid1 = generate_kid_from_public_key(public_pem1)
        kid2 = generate_kid_from_public_key(public_pem2)

        assert kid1 != kid2, "Different keys must have different kids"

    def test_provider_kid_matches_generated(self) -> None:
        """RS256Provider kid SHALL match generated kid from public key.

        **Feature: api-best-practices-review-2025**
        **Validates: Requirements 20.1**
        """
        private_pem, public_pem = generate_rsa_key_pair()

        provider = RS256Provider(private_key=private_pem, public_key=public_pem)
        expected_kid = generate_kid_from_public_key(public_pem)

        assert provider.kid == expected_kid
